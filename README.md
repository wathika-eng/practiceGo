# DSA Practice Roadmap

## Week 1: Arrays and Strings

### Easy

- [ ] Find the maximum and minimum element in an array.
- [ ] Reverse an array.
- [ ] Check if an array is sorted.
- [ ] Remove duplicates from a sorted array.
- [x] Find the index of a given element in an array (Linear Search).

### Medium

- [ ] Rotate an array by k steps.
- [ ] Find the second largest element in an array.
- [ ] Move all zeros to the end of an array.
- [ ] Find the first non-repeating character in a string.
- [ ] Check if two strings are anagrams.

### Hard

- [ ] Find the majority element in an array (appears more than n/2 times).
- [ ] Trapping Rain Water problem.
- [ ] Longest Substring Without Repeating Characters.
- [ ] Merge two sorted arrays without extra space.
- [ ] Find the median of two sorted arrays.

---

## Week 2: Sorting and Searching

### Easy

- [ ] Implement Bubble Sort.
- [ ] Implement Selection Sort.
- [ ] Implement Insertion Sort.
- [ ] Search for an element in a sorted array (Binary Search).
- [ ] Find the first and last position of an element in a sorted array.

### Medium

- [ ] Implement Merge Sort.
- [ ] Implement Quick Sort.
- [ ] Find the kth largest element in an array.
- [ ] Find the smallest missing positive integer.
- [ ] Search in a rotated sorted array.

### Hard

- [ ] Count inversions in an array (using Merge Sort).
- [ ] Find the median of a stream of integers.
- [ ] Allocate minimum number of pages (Binary Search application).
- [ ] Find the peak element in an array.
- [ ] Find the square root of a number using Binary Search.

---

## Week 3: Linked Lists

### Easy

- [ ] Reverse a linked list.
- [ ] Find the middle element of a linked list.
- [ ] Detect a cycle in a linked list.
- [ ] Remove duplicates from a sorted linked list.
- [ ] Merge two sorted linked lists.

### Medium

- [ ] Remove the nth node from the end of a linked list.
- [ ] Add two numbers represented by linked lists.
- [ ] Check if a linked list is a palindrome.
- [ ] Intersection of two linked lists.
- [ ] Flatten a multilevel doubly linked list.

### Hard

- [ ] Reverse a linked list in groups of k.
- [ ] Clone a linked list with random pointers.
- [ ] LRU Cache implementation.
- [ ] Merge k sorted linked lists.
- [ ] Find the starting point of a cycle in a linked list.

---

## Week 4: Stacks, Queues, and Recursion

### Easy

- [ ] Implement a stack using arrays.
- [ ] Implement a queue using arrays.
- [ ] Check for balanced parentheses.
- [ ] Reverse a string using a stack.
- [ ] Implement a queue using two stacks.

### Medium

- [ ] Next Greater Element (using a stack).
- [ ] Design a stack that supports getMin() in O(1) time.
- [ ] Implement a circular queue.
- [ ] Evaluate a postfix expression.
- [ ] Generate all valid parentheses combinations.

### Hard

- [ ] Largest Rectangle in a Histogram.
- [ ] Implement a queue using a linked list.
- [ ] Solve the Tower of Hanoi problem using recursion.
- [ ] Find the next smaller element in an array.
- [ ] Implement a stack that supports getMin() and getMax() in O(1) time.

---

## Week 5: Trees and Binary Search Trees (BST)

### Easy

- [ ] Find the height of a binary tree.
- [ ] Check if two trees are identical.
- [ ] Inorder, Preorder, and Postorder traversals.
- [ ] Find the maximum depth of a binary tree.
- [ ] Check if a binary tree is symmetric.

### Medium

- [ ] Construct a binary tree from inorder and preorder traversals.
- [ ] Validate a Binary Search Tree (BST).
- [ ] Find the lowest common ancestor (LCA) of two nodes in a BST.
- [ ] Convert a sorted array to a balanced BST.
- [ ] Find the kth smallest element in a BST.

### Hard

- [ ] Serialize and deserialize a binary tree.
- [ ] Flatten a binary tree to a linked list.
- [ ] Find the diameter of a binary tree.
- [ ] Count the number of unique BSTs with n nodes.
- [ ] Recover a BST with two nodes swapped.

---

## Week 6: Advanced Topics (Graphs, Dynamic Programming, etc.)

### Easy

- [ ] Implement Depth-First Search (DFS) on a graph.
- [ ] Implement Breadth-First Search (BFS) on a graph.
- [ ] Find the number of islands in a grid.
- [ ] Fibonacci sequence using recursion and dynamic programming.
- [ ] Climbing stairs problem (DP).

### Medium

- [ ] Detect a cycle in a directed graph.
- [ ] Topological sorting of a graph.
- [ ] Longest Increasing Subsequence (LIS).
- [ ] Coin Change problem (DP).
- [ ] 0/1 Knapsack problem (DP).

### Hard

- [ ] Dijkstra’s algorithm for shortest path.
- [ ] Find the shortest path in a maze (BFS).
- [ ] Longest Common Subsequence (LCS).
- [ ] Edit Distance problem (DP).
- [ ] Maximum sum subarray (Kadane’s Algorithm).

---

<!-- ## Daily Reminders Integration

1. Use a **task management app** like Todoist or Google Tasks to set daily reminders.
2. Break each day's task into smaller, focused items. Example:
   - Day 1: Complete "Find the maximum and minimum element in an array" and "Reverse an array".
   - Day 2: Complete "Check if an array is sorted" and "Remove duplicates from a sorted array".
3. Set notifications for specific times, like early morning or study hours.
4. Review your progress weekly to adjust the pace or revisit tough topics. -->
